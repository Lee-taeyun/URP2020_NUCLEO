#include "regression.h"
double distanceSquare(Line line, unsigned int idx, double y){
    // index of array work like X values
    // No need speed values
    double numerator, denumerator;    
    numerator = (line.a*idx - y + line.b);
    numerator = numerator*numerator;
    
    denumerator = line.a*line.a +1;
    return numerator/denumerator;
}

double yFrom(Line line, double x){
    return line.a*x + line.b;
}

Line makeLine(int startIdx, double startY, int endIdx, double endY){
    Line line;
    line.a = (endY - startY)/(endIdx-startIdx);
    line.b = startY - line.a*startIdx;
    line.x.start = startIdx;
    line.x.end = endIdx;
    return line;
}

Line getLinearRegression(double* points, Range range){
    double xSum, xSumSqure, ySum, xySum;
    unsigned int length = range.end - range.start;
    xSum = 0;
    xSumSqure = 0;
    ySum = 0;
    xySum = 0;
    for(int i=range.start; i < range.end; i++){
        xSum += i;
        xSumSqure += i*i;
        ySum += points[i];
        xySum += i*points[i];
    }
    Line line;
    line.a = (length*xySum - xSum*ySum) / (length*xSumSqure - xSum*xSum);
    line.b = (ySum - line.a*xSum)/length;
    line.x.start = range.start;
    line.x.end = range.end;
    return line;
}

void split(Line line, double* points, Range range, unsigned int depth, const unsigned int maxDepth,
            Line* lineContainer, int* containerCurrentLen){
    float middleIdx = (range.start+range.end)/2;
    unsigned int needleMinIdx, needleMaxIdx, needleIdx;
    needleMinIdx = range.start;
    needleMaxIdx = range.start;

    for(int i = range.start; i<range.end; i++){
        //fine needleMax, needleMin
        if(distanceSquare(line, needleMinIdx, points[needleMinIdx]) > distanceSquare(line,i,points[i])){
            needleMinIdx = i;
        }
        if(distanceSquare(line, needleMaxIdx, points[needleMaxIdx]) < distanceSquare(line,i,points[i])){
            needleMaxIdx = i;
        }
    }
    if( ABS(middleIdx-needleMaxIdx) >  ABS(middleIdx-needleMinIdx) ){
        needleIdx = needleMinIdx;
    }else{
        needleIdx = needleMaxIdx;
    }

    if( ((needleIdx - range.start) > 1) && ((range.end - needleIdx) > 1) ){
        Range leftRange, rightRange;
        leftRange.start = range.start;
        leftRange.end = needleIdx;
        rightRange.start = needleIdx;
        rightRange.end = range.end;
        Line leftLine = getLinearRegression( points, leftRange);
        Line rightLine = getLinearRegression( points, rightRange);
        if(depth == maxDepth-1){
            lineContainer[*containerCurrentLen] = leftLine;
            lineContainer[*containerCurrentLen+1] = rightLine;
            *containerCurrentLen += 2;
        }else{
            split(leftLine, points, leftRange, depth+1, maxDepth, lineContainer, containerCurrentLen);
            split(rightLine, points, rightRange, depth+1, maxDepth, lineContainer, containerCurrentLen);
        }
    }else{
        lineContainer[*containerCurrentLen] = line;
        *containerCurrentLen += 1;
    }
}

Line* getTrendLine(double* dataSet, const int lenOfData, const int maxDepth){
    // lineContainer should be free in main loop;
    // size of lineContainer = 2^maxDepth
    unsigned int maxNumOfLines = 1;
    int currentNumOfLines = 0;

    maxNumOfLines = maxNumOfLines << maxDepth;
    Line* lineContainer = (Line*) calloc(maxNumOfLines, sizeof(Line));

    Range range0;
    range0.start = 0;
    range0.end = lenOfData;
    Line line0 = getLinearRegression(dataSet, range0);

    //fill linecontainer with lines generated by partial linear regression
    split(line0, dataSet, range0, 0, maxDepth, lineContainer, &currentNumOfLines);

    int startX, endX;
    double startY, endY;
    for(int i=0; i<currentNumOfLines-1;i++){
        line0 = lineContainer[i];
        startX = line0.x.start;
        startY = yFrom(line0, startX);
        
        line0 = lineContainer[i+1];
        endX = line0.x.start;
        endY = yFrom(line0, endX);

        Line line = makeLine(startX, startY, endX, endY);
        lineContainer[i] = line;
    }
    for(int i=currentNumOfLines; i< maxNumOfLines; i++){
        lineContainer[i].a = -1;
        lineContainer[i].b = -1;
    }
    return lineContainer;
}
int getMaxLenOFContainer(int maxDepth){
    return 1<<maxDepth;
}

int sizeofLineContainer(Line* container, int maxLenOfContainer){
    for(int i = 0; i<maxLenOfContainer;i++){
        if(container[i].a == -1 && container[i].b == -1 && container[i].x.start==0 && container[i].x.end==0){
            return i+1;
        }
    }
    return maxLenOfContainer;
}

double getCurrentValue(double speed, const int maxSpeed, const int lenOfData, Line* lineContainer, int lenOfContainer){
    //speed : 0 - maxSpeed
    //dataIdx : 0 - lenOfData
    double x = ((double)lenOfData)*speed/((double)maxSpeed);
    double y;
    for(int i=0; i < lenOfContainer; i++){
        if( x>= lineContainer[i].x.start && x<lineContainer[i].x.end){
            return yFrom(lineContainer[i], x);
        }
    }
    return yFrom(lineContainer[lenOfContainer-1],x);
}